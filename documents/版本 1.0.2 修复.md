# 版本 1.0.2 修复，分布式公平信号量键在 Redis 集群中的适配

## 问题
在原来的公平信号量键设计中，同一个资源的相关信号量键很可能被映射到集群中的不同节点，
违反 Redis 脚本中所有键都必须在集群的同一个节点的规则，导致 Lua 脚本无法执行：

```java
/** Redis 公平信号量默认实现。*/
@Slf4j
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class DefaultRedisFairSemaphoreImpl implements RedisFairSemaphore 
{
    /* ... */
    
    /** 组合信号量拥有者有序集合键。*/
    @Contract(pure = true)
    private static @NotNull String
    getSemaphoreOwnerKey(String semaphoreName) {
        return semaphoreName + ":" + "owner";
    }

    /** 组合信号量计数器数据键。*/
    @Contract(pure = true)
    private static @NotNull String
    getSemaphoreCounterKey(String semaphoreName) {
        return semaphoreName + ":" + "counter";
    }

    /* ... */
}
```

## 修复方案

在 Redis 集群中，键通过 [CRC-16](https://github.com/redis/redis/blob/unstable/src/crc16.c) 哈希算法分配到不同的槽（slot）中，
想要保证同一个资源的相关信号量键 100% 的映射到同一个槽中，需要使用哈希标签（hash tag）：

```java
@Slf4j
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class DefaultRedisFairSemaphoreImpl implements RedisFairSemaphore 
{
    /* ... */
    
    /** 公平信号量键的键前缀（用户自定义）。*/
    private String FAIR_SEMAPHORE_KEY_PREFIX;

    /** 组合信号量有序集合键。*/
    @Contract(pure = true)
    private @NotNull String
    getSemaphoreNameKey(String semaphoreName) {
        return FAIR_SEMAPHORE_KEY_PREFIX + "{" + semaphoreName + "}";
    }

    /** 组合信号量拥有者有序集合键。*/
    @Contract(pure = true)
    private @NotNull String
    getSemaphoreOwnerKey(String semaphoreName)
    {
        return
        FAIR_SEMAPHORE_KEY_PREFIX + "{" + semaphoreName + "}:" + "owner";
    }

    /** 组合信号量全局计数器数据键。*/
    @Contract(pure = true)
    private @NotNull String
    getSemaphoreCounterKey(String semaphoreName)
    {
        return
        FAIR_SEMAPHORE_KEY_PREFIX + "{" + semaphoreName + "}:" + "counter";
    }

    /* ... */
}
```

这样修复后，Redis 在映射键的时候，仅计算 `crc16(semaphoreName) % 16384` 的值，
保证同一资源的相关信号量键 100% 映射到同一个槽中，从而保证信号量脚本的正确执行。