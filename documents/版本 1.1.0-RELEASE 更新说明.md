# 版本 1.1.0-RELEASE 更新说明

## 1. 分布式锁的时间精度提升至毫秒级别

在原来的接口中，我使用 `long` 类型来表示时间，显然这不是最佳实践：

```java
/** Redis 分布式锁接口类。*/
public interface RedisDistributedLock
{
    /**
     * 兼容响应式流的 Redis 分布式锁操作，
     * 使用 {@link Mono#usingWhen(Publisher, Function, Function)} 方法，
     * 在业务逻辑（action）范围前后，自动完成信号量的获取与释放操作。
     *
     * @param <T> 在锁作用域中业务逻辑返回的类型
     *
     * @param lockName       锁名
     * @param acquireTimeout 获取锁的实现期限
     * @param lockTimeout    锁本身的持有时间期限
     * @param action         业务逻辑
     *
     * @return 发布业务逻辑执行结果数据的 {@link Mono}
     */
    <T> Mono<T>
    withLock(
        String lockName,
        long acquireTimeout, long lockTimeout,
        Function<String, Mono<T>> action
    );
}
```

现在我使用 `Duration` 类型来表示时间，更加灵活，
比如 分布式锁接口 的代码：

```java
/** Redis 分布式锁接口类。*/
public interface RedisDistributedLock
{
    /**
     * 兼容响应式流的 Redis 分布式锁操作，
     * 使用 {@link Mono#usingWhen(Publisher, Function, Function)} 方法，
     * 在业务逻辑（action）范围前后，自动完成信号量的获取与释放操作。
     *
     * @param <T> 在锁作用域中业务逻辑返回的类型
     *
     * @param lockName       锁名
     * @param acquireTimeout 获取锁的实现期限（毫秒级）
     * @param lockTimeout    锁本身的持有时间期限（毫秒级）
     * @param action         业务逻辑
     *
     * @return 发布业务逻辑执行结果数据的 {@link Mono}
     */
    <T> Mono<T>
    withLock(
        String lockName,
        Duration acquireTimeout, Duration lockTimeout,
        Function<String, Mono<T>> action
    );
}
```

此外，Lua 脚本也为毫秒级精度做了修改，示例如下：

```lua
--[[
    尝试获取一个分布式锁。

    KEYS:
        lockKeyName 分布式锁键

    ARGV:
        identifier      本锁的唯一标识符
        acquireTimeout  尝试获取锁的时间限制（毫秒级）
        lockTimeout     锁本身的持有时间限制（毫秒级）
]]

--[[
    由于脚本中出现了 TIME 这样的非确定命令，
    因此这里需要调用 redis.replicate_commands() 显式的开启单命令模式。
]]
redis.replicate_commands()

local lockKeyName = KEYS[1]

local identifier = ARGV[1]
local acquireTimeout = tonumber(ARGV[2])
local lockTimeout = tonumber(ARGV[3])

-- 分布式锁想避免 “时间漂移” 很难，
-- 但统一时间源头可以尽可能地避免这一点
local function getCurrentMillis()
    local time = redis.call('TIME')

    return tonumber(time[1]) * 1000 + math.floor(tonumber(time[2]) / 1000)
end

local now = getCurrentMillis()
local acquireEnd = now + acquireTimeout

-- 在指定期限内尝试获取锁
while
getCurrentMillis() < acquireEnd
do
    if
    -- 尝试设置值
    --（NX （Not Exist）选项表示只有 lockKeyName 不存在时能设置成功）
    --（PX （Expire）选项设置这个锁的有效期为多少毫秒）
    redis.call(
            'SET', lockKeyName, identifier,
            'NX', 'PX', lockTimeout
    ) ~= nil
    then
        return '{"result": "SUCCESS"}'
    end

    -- 若干设置值不成功，检查这个锁的 TTL
    local ttl = redis.call('PTTL', lockKeyName)

    if ttl == -2 then
        -- 锁不存在 NOTHING TO DO
    else if
    ttl == -1
    then
        -- 锁存在但是没有设置 TTL，补上避免永续锁
        redis.call('PEXPIRE', lockKeyName, lockTimeout)
    else if
        -- 锁存在且还有效，检查一下释放为自己的锁
        redis.call('GET', lockKeyName) == identifier
        then
            -- 如果是自己的锁，要续期
            redis.call('PEXPIRE', lockKeyName, lockTimeout)
            return '{"result": "SUCCESS"}'
        end
    end
    end

    -- 如果距离超时还差最后 100 毫秒时还没获取到锁，那可以考虑提前失败了
    if
    getCurrentMillis() + 100 >= acquireEnd
    then
        break
    end

    -- 在每一次检查循环的末尾让出执行权
    -- 避免长时间占有服务器（可能有问题？）
    -- redis.breakpoint()
end

-- 若在指定时间内没有拿到锁，则为获取锁超时
return '{"result": "GET_LOCK_TIMEOUT"}'
```

## 2. 修复分布式公平信号量操作出错导致的流中断问题

在原来的分布式公平信号量设计中存在一个缺陷，先看代码

```java
public class DefaultRedisFairSemaphoreImpl implements RedisFairSemaphore
{
    /* ... */

    /**
     * 兼容响应式流的 Redis 公平信号量操作，
     * 使用 {@link Mono#usingWhen(Publisher, Function, Function)} 方法，在业务逻辑（action）范围前后，
     * 自动完成信号量的获取与释放操作。
     *
     * @param <T> 在信号量作用域中业务逻辑返回的类型
     *
     * @param semaphoreName 信号量键名（例 semaphore:remote）
     * @param limit         最大信号量值
     * @param timeout       信号量有效期（单位：秒）
     * @param action        业务逻辑
     *
     * @return 发布业务逻辑执行结果数据的 Mono
     */
    @Override
    public <T> Mono<T>
    withFairSemaphore(
        String semaphoreName,
        long limit, long timeout,
        Function<String, Mono<T>> action)
    {
        final String semaphoreNameKey = getSemaphoreNameKey(semaphoreName);

        return
        Mono.defer(() ->
            Mono.usingWhen(
                this.acquireFairSemaphore(semaphoreNameKey, limit, timeout)
                    .map((identifier) -> identifier),
                (identifier) -> {
                    Mono<T> actionMono = action.apply(identifier);

                    if (timeout > 10)
                    {
                        // 刷新间隔为超时时间的一半
                        Duration refreshInterval
                            = Duration.ofSeconds(timeout / 2);

                        return 
                        actionMono.delayUntil((value) ->
                           Flux.interval(refreshInterval)
                               .takeUntilOther(
                                   actionMono.ignoreElement().then(Mono.empty()))
                               .concatMap((ignore) ->
                                   this.refreshFairSemaphore(semaphoreNameKey, identifier))
                               .then()
                        );
                    }

                    return actionMono;
                },
                (identifier) ->
                    this.releaseFairSemaphore(semaphoreNameKey, identifier)
            )
        );
    }   
    
    /* ... */
}
```

时间精度的问题条目 1 已经讲过了，
但还应该考虑这么一个情况：如果某个进程长期持有一个信号量，在刷新信号量的过程中出现了未知错误，
现有的设计会触发连锁反应，导致整个业务逻辑被终止。
当然处理办法也很简单，使用 `.onErrorContinue()` 操作即可，如下所示

```java
public class DefaultRedisFairSemaphoreImpl implements RedisFairSemaphore
{
    /**
     * 兼容响应式流的 Redis 公平信号量操作，
     * 使用 {@link Mono#usingWhen(Publisher, Function, Function)} 方法，在业务逻辑（action）范围前后，
     * 自动完成信号量的获取与释放操作。
     *
     * @param <T> 在信号量作用域中业务逻辑返回的类型
     *
     * @param semaphoreName 信号量键名
     * @param limit         最大信号量值
     * @param timeout       信号量有效期（毫秒级）
     * @param action        业务逻辑
     *
     * @return 发布业务逻辑执行结果数据的 Mono
     */
    @Override
    public <T> Mono<T>
    withFairSemaphore(
        String semaphoreName,
        long limit, Duration timeout,
        Function<String, Mono<T>> action
    )
    {
        final String semaphoreNameKey    = getSemaphoreNameKey(semaphoreName);
        final long   milliSecondsTimeout = timeout.toMillis();

        return
        Mono.defer(() -> 
            Mono.usingWhen(
                this.acquireFairSemaphore(semaphoreNameKey, limit, milliSecondsTimeout)
                    .map((identifier) -> identifier),
                (identifier) -> {
                    Mono<T> actionMono = action.apply(identifier);

                    // 对持有信号量时间较长的进程，才提供刷新功能
                    if (timeout.compareTo(LONG_TIMEOUT) > 0)
                    {
                        // 刷新间隔为超时时间的一半
                        Duration refreshInterval
                            = Duration.ofMillis(milliSecondsTimeout)
                                      .dividedBy(2L);
                            
                        return
                        actionMono.delayUntil((value) ->
                              Flux.interval(refreshInterval)
                                  .takeUntilOther(
                                       actionMono.ignoreElement().then(Mono.empty()))
                                  .concatMap((ignore) ->
                                       this.refreshFairSemaphore(semaphoreNameKey, identifier)
                                           .onErrorContinue(  // 刷新信号量操作可能出错，但不能中断整个流
                                               SemaphoreNotFound.class,
                                               (exception, object) -> { /* NOTHING TO DO */}
                                           )
                                  ).then()
                        );
                    }

                    return actionMono;
                },
                (identifier) ->
                    this.releaseFairSemaphore(semaphoreNameKey, identifier)
                )
            );
    }
}
```

# 3. 统一依赖中 Redis 操作的超时时间

现在可以直接在配置里面编写属性来统一超时时间：

```yml
app:
  redis-lock:
    # Redis 操作的统一超时时间（默认为 5 秒）
    operation-timeout: 5s
```

*2025.11.12*
