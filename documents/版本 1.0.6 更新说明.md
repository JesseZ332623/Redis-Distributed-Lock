# 版本 1.0.6 更新说明

## 1.  新增 Lua 脚本缓存策略

原来的 `LuaScriptReader` 没有实现缓存 `DefaultRedisScript<LuaOperatorResult>` 实例的策略，在高并发的情况下会频繁的去文件系统中读取脚本，这会成为性能瓶颈，所以我增加了缓存机制，确保脚本实例不会被反复读取。核心代码如下所示：

```java
final public class LuaScriptReader 
{
      /** ... */
      /** Lua 脚本缓存：operatorType -> (scriptName -> script) */
     private final ConcurrentMap<
         LuaScriptOperatorType,
         ConcurrentMap<String, DefaultRedisScript<LuaOperatorResult>>>
         scriptCache = new ConcurrentHashMap<>();

     @Autowired
     @Qualifier("distributedLockScheduler")
     private Scheduler scheduler;

      /** 获取或者创建指定操作类型的脚本缓存。*/
    private ConcurrentMap<String, DefaultRedisScript<LuaOperatorResult>>
    getOrCreateScriptCache(LuaScriptOperatorType scriptOperatorType)
    {
        return
        this.scriptCache.computeIfAbsent(
            scriptOperatorType,
            (scriptName) -> new ConcurrentHashMap<>()
        );
    }

    /**
     * 通过操作类型 + 脚本名尝试从缓存中获取指定的
     * {@link DefaultRedisScript<LuaOperatorResult>}，没有则从 classpath 中加载然后缓存。
     *
     * @param operatorType  Lua 脚本类型
     * @param luaScriptName Lua 脚本名
     *
     * @return 由 {@link DefaultRedisScript} 包装的，
     *         发布 Lua 脚本执行结果 {@link LuaOperatorResult} 的 {@link Mono}
     */
    private @NotNull Mono<DefaultRedisScript<LuaOperatorResult>>
    getScriptFromCache(LuaScriptOperatorType operatorType, String luaScriptName)
    {
        return
        Mono.fromCallable(() -> {
            ConcurrentMap<String, DefaultRedisScript<LuaOperatorResult>>
                operatorCache = this.getOrCreateScriptCache(operatorType);

            // 调用 computeIfAbsent() 方法，
            // 存在则直接返回，不存在执行 mappingFunction 缓存后再返回。
            return
            operatorCache.computeIfAbsent(
                luaScriptName,
                (scriptName) -> {
                    try
                    {
                        return
                        this.loadFromClassPath(operatorType, luaScriptName);
                    }
                    catch (IOException exception)
                    {
                        throw new
                        LuaScriptOperatorFailed(
                            format(
                                "Load lua script %s failed! Caused by: %s",
                                luaScriptName, exception.getMessage()),
                            exception
                        );
                    }
                }
            );
        });
    }
    /** ... */
}
```

## 2.  为项目内所有 I/O 密集型操作配置统一的调度器

在原来的代码中，没有为 Lua 脚本读取、Lua 脚本执行这样的 I/O 操作配置调度器，
按照响应式架构的设计，对于没有指定调度器的响应式流，订阅后一般由事件循环线程（ioEventLoop）执行，显然让宝贵的事件循环线程去执行 I/O 操作是不合理的，所以我为本项目配置了专用的调度器，如下所示：

```java
    /** Redis Lock 专用的线程调度器 Bean。*/
    @Bean(name = "distributedLockScheduler")
    public Scheduler
    distributedLockScheduler(RedisLockProperties properties)
    {
        RedisLockProperties.ProjectSchedulersProperties
            schedulersProperties = properties.getSchedulers();

        return
        Schedulers.newBoundedElastic(
            schedulersProperties.getMaxThreads(),
            schedulersProperties.getTaskQueueCapacity(),
            schedulersProperties.getThreadName(),
            schedulersProperties.getTtlSeconds(),
            schedulersProperties.isDaemon()
        );
    }
```

用户可以根据自己项目的负载程度在配置中自定义调度器的相关参数，示例如下：

```yml
app:
  redis-lock:
    schedulers:
      # 最大线程数（默认 100 线程）
      max-threads: 100
      # 任务队列容量（默认 1000）
      task-queue-capacity: 1000
      # 调度线程名（默认 redis-lock）
      thread-name: redis-lock
      # 空闲线程存活时间（默认 60 秒）
      ttl-seconds: 60
      # 是否开启守护线程？（对于分布式锁操作来说是必须的）
      daemon: true
```

这个调度器被用在了某些关键的位置，关键代码如下所示：

```java
   /**
     * 尝试获取一个锁。
     *
     * @param lockName          锁名
     * @param acquireTimeout    获取锁的时间期限
     * @param lockTimeout       锁本身的有效期（单位：秒）
     *
     * @return 返回一个 Mono，成功获取锁时发布锁的唯一标识符（UUID）
     */
    private @NotNull Mono<String>
    acquireLockTimeout(
        String lockName, long acquireTimeout, long lockTimeout)
    {
        final String lockKeyName = getRedisLockKey(lockName);
        final String identifier  = UUID.randomUUID().toString();

        return
        this.luaScriptReader
            .read(DISTRIBUTE_LOCK, "acquireLockTimeout.lua") // Lua 脚本执行在指定调度器
            .flatMap((script) ->
                this.scriptRedisTemplate
                    .execute(
                        script,
                        List.of(lockKeyName),
                        identifier, acquireTimeout, lockTimeout)
                    .next()
                    .subscribeOn(this.scheduler) // Lua 脚本执行在指定调度器
                    .flatMap((result) ->
                        switch (result.getResult())
                        {
                            case "GET_LOCK_TIMEOUT" ->
                                Mono.error(
                                    new RedisDistributedLockAcquireTimeout(
                                        format(
                                            "Acquire lock: %s timeout! (acquireTimeout = %d seconds)",
                                            lockName, acquireTimeout
                                        )
                                    )
                                );

                            case "SUCCESS" -> Mono.just(identifier);

                            case null, default ->
                                Mono.error(
                                    new IllegalStateException(
                                        "Unexpected value: " + result.getResult()
                                    )
                                );
                        }
                    )
            ).onErrorResume(RedisLockErrorHandle::redisLockGenericErrorHandle);
    }
```

*2025.11.07*